<script setup>
import stQuote from "@/components/Card/st-quote.vue";
import {
  strategymodehead,
  xiaomingstory,
  xiaomingcodewithoutagent,
  xiaomingcodewithfine,
  xiaomingcodewithfakeragent,
  imgwithout,
  imgwithagent,
  savewithagent,
  heightsavewithagent,
} from "../data/agentmode";
</script>

<template>
  <div class="combox">
    <h2>代理模式</h2>
    <div>
      <p>前言：</p>
      <stQuote class="mg-b10" :ctx="strategymodehead" />
      在我看来，代理模式就像是web的架构，用户通过代理（浏览器，网页）访问本体的功能（服务器，接口）。
      <br />
      举个例子：
      <br />
    </div>

    <div>
      <div>
        <h3>1.小明追mm</h3>
        <div>
          <stQuote class="mg-b10" :ctx="xiaomingstory" />
          下面用代码描述一下小明追女神的过程，用了最简单的代理：
          <pre>{{ xiaomingcodewithoutagent }}</pre>
          很疑惑，小明自己送花和代理送花，二者在目的上没有区别，引入一个代理看起来将事情变得更复杂了。
          <br />
          确实，此处的代理没有用处，它只是将请求简单的转到了目标对象。但不管怎么，这也算引入了代理。
          <br />
          现在，改一下设定，当a心情好的时候，小明表白的概率有60%，当心情差的时候，这个概率无限接近0！
          <br />
          小明不知道女神a的情况，无法判定女神心情的好坏，但代理b是女神的好友，知道女神的心情变化。这个时候的代码：
          <pre>
            {{ xiaomingcodewithfine }}
          </pre>
          <span class="color-p1">
            这里用代理监听了本体的状态，根据本体的状态不同，代理对用户的请求做出不同的处理，这或许就是代理的意义之一吧。
          </span>
        </div>
      </div>

      <div>
        <h3>2.保护代理和虚拟代理</h3>
        <div>
          假设花的价格很高，我们可以将new
          Flower的操作交由代理去执行。代理会在女神心情好的时候再执行new
          Flower的操作。
          <br />
          这个就是代理模式的一种形式：<span class="color-red">虚拟代理</span>
          <br />
          虚拟代理会将一些开销大的对象，延迟到真正需要它的时候创建:
          <pre>
            {{ xiaomingcodewithfakeragent }}
          </pre>
          保护代理用于控制不同权限的对象对目标对象的访问？但js并不同意实现保护代理，因为我们无法判断谁访问了某个对象。而虚拟代理是最常用的一种代理模式。
        </div>
      </div>

      <div>
        <h3>3.虚拟代理实现图片预加载</h3>
        <div>
          web开发中，图片预加载是一种常用的技术，若直接给某个img标签添加src属性，由于图片过大或者网络不佳，图片往往有段时间会以空白显示。
          最常见的做法是使用loading图片进行占位。然后用异步的方式加载图片，等图片资源加载完毕后再填充到img节点里。这种场景就很适合虚拟代理。
          <pre>
            {{ imgwithout }}
          </pre>
          将网速调整至5kb/s
          会发现页面中有一段长时间的空白。现在引入代理，通过这个代理，在图片加载完成前，页面将出现占位图gif提示用户正在加载：
          <pre>
            {{ imgwithagent }}
          </pre>
          现在我们通过代理间接访问了myimage，并且在这个过程中加入了一些额外的操作，比如真正的图片加载好之前，先将img节点的src设置为一张本地的loading图片
        </div>
      </div>

      <div>
        <h3>4.代理的意义</h3>
        <div>
          为了说明代理的意义，再回顾一下单一职责原则。<br />
          单一职责原则指的是，一个类（通常指对象和函数）而言，应该仅有一个引起它起变化的原因。
          若一个对象承担多个职责，那么意味这个类变得巨大，当这些职责糅合在一起，这种糅合会导致脆弱和低内聚的设计。
          当变化发生，设计可能遭受的意外的破坏导致程序出错。
          <br />
          上述例子中的img对象除了负责给img节点设置src外，还要负责加载预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职
          责的实现。
          <br />
          另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放—
          封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者5年后的网速快到根本不再需
          要预加载，我们可能希望把预加载图片的这段代码从MyImage对象里删掉。这时候就不得不改动
          MyImage对象了。
          实际上，我们需要的只是给img节点设置src，预加载图片只是一个锦上添花的功能。如果
          能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出
          来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体MyImage。
          <br />
          纵观整个程序，我们并没有改变或者增加MyImage的接口，但是通过代理对象，实际上给系
          统添加了新的行为。这是符合开放—封闭原则的。给img节点设置src和图片预加载这两个功能，
          被隔离在两个对象里，它们可以各自变化而不影响对方。何况就算有一天我们不再需要预加载，
          那么只需要改成请求本体而不是请求代理对象即可。
        </div>
      </div>

      <div>
        <h3>5.代理和本体接口的一致性</h3>
        <div>
          上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请
          求本体。其中关键是代理对象和本体都对外提供了 setSrc
          方法，在客户看来，代理对象和本体 是一致的，
          代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这
          样做有两个好处。
          <br />
          1.用户可以放心请求代理，他只关心是否能得到想要的结果 <br />
          2.在任何使用本体的地方都可以替换使用代理<br />
          在java里，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥有同样的方法，
          另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开编译器的类型检测，代理和本体将来可以被替换使用？
          <br />
          在js这种动态类型的语音中，我们有时通过鸭子类型来检测代理和本体是否都实现了setSrc方法，另外大多数的时候甚至干脆不做检测，全部依赖开发者的自觉，对于程序的健壮性是有影响的。
          不过对于一门快速开发的脚本语音，这些影响还是可以在可以接受的范围之内，而且我们已经习惯了没有接口的世界？
          （此处代码略，没看懂）
        </div>
      </div>

      <div>
        <h3>6.虚拟代理合并http请求</h3>
        <div>
          有这样一个场景，每周我们都要写一封工作报告交给领导，领导手下150个人，领导一个一个看肯定是费事费神的，所以一般交给组长进行收集提炼后再给领导。
          <br />
          这个例子在程序的世界也常见，比如web开发中的网络开销，假设我们在做一个文件同步的功能，当我们选中一个checkbox的时候，它就会被同步到另一个服务器里。
          <br />
          点击一个不是什么问题，但若有用户在短时间点击多个文件（发送同步请求）如此频繁的请求会带来庞大的开销。<br />
          解决方案是使用一个代理函数来收集一段时间的请求，最后一次性发送个服务器。（代码略）
        </div>
      </div>

      <div>
        <h3>7.缓存代理</h3>
        <div>
          缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参
          数跟之前一致，则可以直接返回前面存储的运算结果。
          <br />
          <pre
            >{{ savewithagent }}
          </pre>
          不同于之间介绍的闭包缓存，这个缓存是由代理实现的，mult函数本身可以专注于计算了。
          <br />
          此外缓存代理也可以用于分页需求中（减少请求量），当分页数据不大的时候，可以通过缓存的方式直接将数据缓存下来。
        </div>
      </div>

      <div>
        <h3>8.高阶函数动态创建代理</h3>
        <div>
          通过传入高阶函数这种更加灵活的方式，可以为各种计算方法创建缓存代理。现在这些计算方法被当作参数传入一个专门用于创建缓存代理的工厂中，
          这样一来，我们就可以为乘法、加 法、减法等创建缓存代理，代码如下：
          <br />
          <pre
            >{{ heightsavewithagent }}
          </pre>
        </div>
      </div>

      <div>
        <h3>9.其他代理模式</h3>
        <div>
          代理模式的变体种类非常多，限于篇幅及其在JavaScript中的适用性，本章只简约介绍一下
          这些代理，就不一一详细展开说明了。
          <br />
          1.防火墙代理：控制网络资源的访问，保护主题不让坏人接近。<br />
          2.远程代理：为一个对象在不同地址的空间提供局部代表？在java中远程代理可能是另一个虚拟机。<br />
          3.保护代理：用于对象有不同的保护对象。<br />
          4.只能引用代理：取代简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数。<br />
          5.写时复制代理：通常用于复制一个庞大的对象情况。写时复制代理延迟了复制的过程，当对象被真正修改的时候，才对他进行复制操作。
          写时复制代理是虚拟代理的一种变体，DLL（操作系统中的动态链接库）是其典型的运用场景。
        </div>
      </div>
    </div>
  </div>
</template>

<style lang="less" scoped>
.combox {
  width: 100%;
}
pre {
  padding-left: 10px !important;
}
</style>
