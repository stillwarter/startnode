<script setup>
import stQuote from "@/components/Card/st-quote.vue";
import {
  jsoopinfo,
  jsoopcodeinfo,
  jsoopcodeinfopol,
  jsoopcodeinfoP,
  jsoopundestand,
  jsoopcodeinfoNoP,
  jsooptype,
  jsoopextend,
  jsoopwork,
  jsooppackage,
  jsooppackagecode,
  jsooppackagechange,
  jsoopclone,
  jsoopobjprototype,
  jsoopobjnew,
  jsoopundestandnew,jsoopthis,jsoopthisf1
} from "../data/designmodule";
</script>

<template>
  <div class="jsoopbox">
    <div>
      <h2>1.面向对象的JavaScript</h2>
      <div>
        <p>前言：</p>
        <stQuote class="mg-b10" :ctx="jsoopinfo" />
      </div>

      <div>
        <h3>1.1 动态类型语言和鸭子类型</h3>
        <div>
          <p>
            编程语言按数据类型大体可以分为2类，一类是静态语言类型，一类是动态语言类型。<br />
            静态类型语言在编译时已经确定变量的类型，而动态类型语言的变量类型需要程序运行时，待到变量被赋予某个值之后，才会被确定时某某类型。<br />
            所以对于js来说，他是一门典型的动态语言类型。
          </p>
          <p>
            动态语言类型对变量类型的宽容度给实际编码带来了很大的灵活性（同时也减弱了他的可维护性），
            由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。
          </p>
          <p>
            这一切都建立在<span style="color: blueviolet;"
              >鸭子类型(duck typing)</span
            >
            的概念上，鸭子类型的通俗说法是：若它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。
            <br />
            我们可以通过一个小故事来更深刻地了解鸭子类型. 从前在 JavaScript
            王国里, 有一个国王, 他觉得世界上最美妙的声音就是鸭子的叫声,
            于是国王召集大臣, 要组建一个 1000 只鸭子组成的合唱团.
            大臣们找遍了全国, 终于找到 999 只鸭子, 但是始终还差一只,
            最后大臣发现有一只非常特别的鸡, 它的叫声跟鸭子一模一样,
            于是这只鸡就成为了合唱团的最后一员. <br />
          </p>
          <div>
            让我们用代码模拟一下这个场景：
            <pre>
          {{ jsoopcodeinfo }}
        </pre
            >

            从代码能看出，我们无需检测其类型，只需要保证它拥有duskSinging方法就行。
          </div>
          <p>
            在动态类型语言的面向对象设计中, 鸭子类型的概念至关重要.
            利用鸭子类型的思想, 我们不必借助超类型的帮助,
            就能轻松地在动态类型语言中实现一个原则:
            <span style="color: red;"
              >"面向接口编程, 而不是面向实现编程。"</span
            >
          </p>
          <p>
            比如，一个对象又push和pop方法，并且这些方法提供了正确的实现，那它就可以被当作栈来使用。
            一个对象若有length属性，也可以依照下标来存取属性（最好还拥有slice和splice等方法），这个对象就能被当作数组来使用。
          </p>
          <p>
            在静态类型语言中，要实现面向接口编程并不是一件容易的事情，
            <span style="color: rgb(224, 125, 208);"
              >往往要通过抽象类或者接口等将对象进行向上转型.
              当对象的真正类型被隐藏在它的超类型身后,
              这些对象才能在类型检查系统的 "监视" 之下互相被替换使用.
              只有当对象能够被互相替换使用, 才能体现出对象多态性的价值.</span
            >
          </p>
          <p>
            <span style="color: red;">面向接口编程</span
            >是设计模式中最重要的思想。<br />
            但在js里，面向接口编程的过程和主流的静态类型语言不一样，所以在js中实现设计模式的过程与在一些我们熟悉的语言中实现大相径庭。
          </p>
        </div>

        <div>
          <div>
            <h3>1.2 多态</h3>
            <div>
              <p>
                "多态"一词源于希腊文 polymorphism, 拆开来看是 poly（复数） +
                morph（形态）+ ism, 从字面上我们可以理解为复数形态。<br />
                多态的实际含义是: 同一操作作用于不同的对象上面,
                可以产生不同的解释和不同的执行结果。<br />
                换句话说，就是给不同对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同反馈。
              </p>
              <p>
                举个例子：<br />
                主人家里养了两只动物, 分别是一只鸭和一只鸡,
                当主人向它们发出"叫"的命令时, 鸭会"嘎嘎嘎"地叫,
                而鸡会"咯咯咯"地叫. 这两只动物都会以自己的方式来发出叫声.
                它们同样"都是动物, 并且可以发出叫声", 但根据主人的指令,
                它们会各自发出不同的叫声.
              </p>
              <div>
                让我们用代码模拟一下这个场景：
                <pre>
              {{ jsoopcodeinfopol }}
            </pre
                >
              </div>
              <p>
                多态背后的事项是将“做什么”和“谁去做以及怎样去做”分离开来，也就是“将不变的事物”和“可能改变的事物”分离。<br />
                在这个例子里，不变的是-动物都会叫，但不同类型的动物具体是怎么叫的是可变的。把不变的分离，可变的进行封装。这将给予程序可以生长的能力，符合开发-封闭原则。<br />
                相对于修改代码来说，仅仅增加代码就能完成同样的功能，这样显然优雅许多（这就是屎山的原因？）。
              </p>
              <div>
                现在用多态的思想改写一下鸭子类型的代码：
                <pre>
              {{ jsoopcodeinfoP }}
            </pre
                >
                把不变的隔离出来，那就是所有动物都会发出叫声；现在我们对鸡鸭都进行发出叫声的请求，他们对请求做出不同的翻译。<br />
                后续我们有加了一只狗，我们想让狗也叫一叫，那么直接追加就行，不需要改原代码。<br />
                反例：
                <pre>
              {{ jsoopcodeinfoNoP }}
            </pre
                >
              </div>
            </div>
            <stQuote class="mg-b10" :ctx="jsoopundestand" />
          </div>
          <div>
            <h3>1.3 类型检查和多态</h3>
            <div>
              类型检查是在表现出对象多态性之前的一个绕不开的话题, 但 JavaScript
              是一门不必进行类型检查的动态类型语言, 为了真正了解多态的目的,
              我们需要转一个弯, 从一门静态类型语言说起。<br />
              之前提到，静态类型语音会在编译德时候进行类型匹配检查。以java为例
              由于代码编译的时候要进行严格的类型检测，所以不能给变量赋予不同类型的值，
              这种类型检查会让代码显得僵硬：
              <pre>
              {{ jsooptype }}
            </pre
              >
              这里已经顺利的让鸭子发出叫声，但若你想让鸡也叫起来，这是不可能的。
              因为行1处animalsound类的makesound方法，被规定只能接受Duck类型参数
            </div>
            <p>
              某些时候，在享受静态语言类型检查带来的安全性的同时，我们亦会感受到被束缚了手脚。
              为解决这一问题，静态类型的面向对象语言通常被设计为可以“向上转型”
              <span style="color: red;"
                >当给一个变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类（父类）。</span
              >
              <br />
              这就是我们在描述一只麻雀在飞的时候，也可以说是一只鸟在飞。<br />
              同理，当duck对象和chicken对象的类型都被隐藏在超类型animal身后，duck对象和chicken对象就能被交换使用。
              这就是让对象体现出多态性的必进之路，而多态的表现正是实现众多设计模式的目标。
            </p>
          </div>
          <div>
            <h3>1.4 使用继承达到多态效果</h3>
            <div>
              <span style="color: red;"
                >使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</span
              >
              继承通常包括“实现继承”和“接口继承” 直接上代码：
              <pre>
              {{ jsoopextend }}
            </pre
              >
            </div>
            <div>
              以上是java的写法，之前的内容其实是让你理解多态的思想--就是把“做什么”和“谁去做”分离开来，
              实现这一点归根结底需要消除类型之间的耦合关系，就是我们需要将makesound方法中指定的对象升级为父类。
              <br />
              而js的变量类型在运行期间是可变的，这意味着<span
                style="color: red;"
                >js对象的多态性是与生俱来的</span
              >。
              <br />
              这并不难理解，js既没有检查创建的对象类型，也没有检查传递的参数类型，所以不会有“类型耦合”。
            </div>
          </div>

          <div>
            <h3>1.5 多态在面向对象程序设计中的作用</h3>
            <div>
              有人认为多态是oop最重要的部分，但目前还是很难体会到，毕竟大部分人不关心鸡鸣狗叫的，让鸡呀鸭呀的发出叫声，这和程序有什么关系呢。
              <br />
              <stQuote class="mg-b10" :ctx="jsoopwork" />
              换言之，多态最根本作用就是通过将‘过程化的条件分支语句’（很多if判断）转化为‘对象的多态性’（不同对象的表现？），
              从而消除这些分支语句。
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>
      <h2>2.封装</h2>
      <div>
        <p>前言：</p>
        <stQuote class="mg-b10" :ctx="jsooppackage" />
      </div>

      <div>
        <div>
          <h3>2.1 封装数据</h3>
          <div>
            在许多语言的对象系统里，封装数据是由语法解析实现的，这些语言也许提供private，public等关键字来提供不同的访问权限。
            <br />
            但js并没有提供对提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性，而且只能模拟public和private。
            除了es6提供的let，一般我们用函数来创建作用域
            <pre>{{ jsooppackagecode }}</pre>
            上述代码使用了立即执行函数，创建了一个私有变量并通过返回的对象，对方的getname方法可以访问这个私有变量。<br />
            <br />
            你可以简单理解为，在这个立即执行函数执行后，我们得到的变量内存在一个隐藏的变量，这个隐藏的变量必须通过getname访问
            （因为，我们并没有直接在返回的对象里声明这个变量，而是将声明放到了立即执行函数里。）
            对于浏览器来说，立即执行函数执行后，似乎并没有销毁立即执行函数的作用域的内存，当我们执行getname函数的时候，依旧可以访问到私有属性。
            <br />
            当然es6中提供symbol特性来创建私有属性。
          </div>
        </div>

        <div>
          <h3>2.2 封装的实现</h3>
          <div>
            <p>
              上一个小点描述了数据的封装，有时候将封装等同于数据封装，是比较狭义的。<br />
              封装的目标是将信息隐藏，封装应该被视为“任何形势的封装”，也就是说，不仅仅是隐藏数据，还包括隐藏实现细节设计细节以及隐藏对象类型等。<br />
              从封装实现细节来说，封装使得对象内部的变化对其他对象而言是透明的，也就是不可见的；
              对象对它自己的行为负责，其他对象或者用户都不关心它内部的实现。
              封装使得对象之间的耦合便松散，对象之间只通过暴露的api接口来通信。当我修改一个对象时，可以随意的修改其内部实现，只要对外的接口不变就不会影响程序的其他功能。
              <br />
              封装实现细节的例子非常多，比如迭代器，迭代器的作用时在一个不暴露聚合对象的内部表示前提下，提供一种方式顺序访问这个聚合对象。
            </p>
          </div>
        </div>

        <div>
          <h3>2.3 封装的类型</h3>
          <div>
            <p>
              封装类型是静态类型语言一种重要的封装方式，一般来说，封装类型是通过抽象类和接口来进行的。
              把对象的真正类型隐藏到抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。在许多静态语言的设计模式里，
              需要刻意的隐藏对象的类型，这也是促使模式诞生的原因。
              <br />
              当然js里没有对抽象类和接口的支持，js本身也是一门类型模糊的语言。在封装类型方面，js没这个能力也无需做的更多。
              对js的设计模式来说，不区分类型是一种失色，也可以是一种解脱。
            </p>
          </div>
        </div>

        <div>
          <h3>2.4 封装变化</h3>
          <div>
            <p>从设计模式的角度出发, 封装在更重要的层面体现在“封装变化”。</p>
            <stQuote class="mg-b10" :ctx="jsooppackagechange" />
            <p>
              上述文字是《设计模式》提到的“找到变化并封装之”。《设计模式》中共归纳总结了23钟设计模式，
              从意图上区分，分为<span style="color: red;"
                >创建型模式，结构型模式，行为型模式。</span
              >
              <br />
              以创建型为例子，创建一个对象，是一种抽象行为，而具体创建声明对象则是可以变化的，
              <span style="color: rgb(224, 125, 208);"
                >创建型模式的目的就是封装创建对象的变化。</span
              >
              <span style="color: rgb(224, 125, 208);"
                >结构型模式的目的就是封装对象之间的组合关系。</span
              >
              <span style="color: rgb(224, 125, 208);"
                >行为型模式封装的是对象的行为变化，目的是将系统中不稳定的部分和容易变化的部分分离开来。</span
              >
              <br />
              从《设计模式》副标题“可复用面向对象软件的基础”可以知道,
              这本书理应教我们如何编写可复用的面向对象程序.
              这本书把大多数笔墨都放在如何封装变化上面,
              这跟编写可复用的面向对象程序是不矛盾的.
              当我们想办法把程序中变化的部分封装好之后,
              剩下的即是稳定而可复用的部分了.
            </p>
          </div>
        </div>
      </div>
    </div>
    <div>
      <h2>3.基于原型继承的js对象系统</h2>
      <div>
        <p>
          在Brendan
          Eich为js设计面向对象系统时，借鉴了self和smalltalk这两门基于原型的语言。选择基于原型的面向对象系统，可能Brendan
          Eich一开始就没打算加入类的概念吧~（虽然在es6进行了补充）
          <br />
          在以类为中心得面向对象编程语言中，类和对象得关系可以想象为铸模和铸件得关系，对象总是从类中创建得。而在原型编程的思想里，类不是必须的，对象也未必非要从类中创建而来，一个对象是通过克隆另外一个对象得到的。
          <br />
          原型模式不但是一种设计模式，也被称为一种编程泛型。这里你会认识到第一个设计模式--原型模式。
          随后会了解到基于原型的Io语言，你将了解js如何通过原型来构建一个面向对象系统。
        </p>
      </div>

      <div>
        <div>
          <h3>3.1 使用克隆的原型模式</h3>
          <div>
            <div>
              从设计模式的角度讲，原型模式是用于创建对象的一种模式，若想要创建一个对象，一个方法是先指定他的类型，
              然后通过类来创建这个对象，原型模式选择了另一种方式，不需要再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。
              <br />
              原型模式的关键是语言本身是否提供了clone方法，es5提供obj.create方法，可以用来克隆对象
              <pre>
              {{ jsoopclone }}
              </pre>
              <p>
                克隆是创建对象的手段，原型模式的真正目的并非在于需要得到一个一模一样的对象，<span
                  style="color: red;"
                  >而是提供一种便捷的方式创建某个类型的对象，克隆只是创建这个对象的手段和过程。
                </span>
                在使用java等静态语言类型编写程序时，类型之间的解耦非常重要，依赖倒置原则提醒我们创建对象的时候要避免依赖具体类型，
                而用new
                xxx创建对象显得很僵硬？？工厂方法和抽象工厂模式可以帮助我们解决这个问题，但这两个模式会带来许多跟产品类平行的工厂类层次，也会增加额外的代码。
                <br />
                原型模式提供提供另外一种创建对象的方式，通过克隆对象，我们不需要关心对象的具体类型名字。在js这种类型模糊的语言里，创建对象很容易
                也不存在类型耦合的问题。从设计模式的角度来讲，原型模式意义不大，但js本身时一种基于原型的面向对象语言，他的对象系统就是使用原型模式搭建的
                这里称为原型编程范型可能更合适。
              </p>
            </div>
          </div>
        </div>

        <div>
          <h3>3.2 js中的原型继承</h3>
          <div>
            <p>接下来我们讨论js是如何在这些规则上构建对象系统的</p>
            <div>
              (1) <span class="color-p1">所有数据都是对象</span>
              <br />
              js在设计的时候，模仿java引入了两套类型机制，基本类型和对象类型。事实上
              js中的根对象时Object.portotype对象，这个对象是一个空对象，我们在js创造的每个对象，实际上都是从obj.prototype对象克隆而来的，
              obj.prototype对象就是他们的原型
              <pre>{{ jsoopobjprototype }}</pre>
            </div>
            <div>
              (2)
              <span class="color-p1"
                >要得到一个对象, 不是通过实例化类,
                而是找到一个对象作为原型并克隆它</span
              >
              <br />
              在lo语言里，克隆一个对象的动作指令非常明显：Dog := Animal clone
              <br />
              但在js里，我们不需要关心克隆细节，因为这是引擎内部负责实现的，我们需要做只是显示的声明一个空对象。
              此时引擎内部就会从obj.prototype上克隆一个对象给我们使用。看个例子：
              <pre>{{ jsoopobjnew }}</pre>
              js没有类的概念，这句话已经重复很多次了，但上面的命名明明使用了new
              Preson()？
              <br />
              <span class="color-red">
                过克隆obj.prototype来得到新，而是构造函数，js的函数既可以作为普通函数被调用，也可以作为构造函数被调用。
                当使用new运算符调用函数时候，此时函数就是一个构造器，用new运算符来创建对象的过程，实际上也是先
                克隆obj.prototype对象，再进行一些其他额外操作的过程。
              </span>
              tips1：我们平时都是用new操作符来调用构造函数，实际上js任何函数都允许使用new，只是做了一个广泛的约定
              使用new就是使用构造器的作用。
              <br />
              tips2：js时通过克隆obj.prototype来得到新对象，但实际上并不是每次克隆都是真正克隆一个新对象，从内存方面考虑
              js还做了一些额外处理，具体细节可以阅读周爱民老师的《js语言精髓与开发实践》
              这里不做深入讨论，暂且讲创建对象的过程看成完全的克隆。
              <br />
              在chrome和firefox等向外暴露了__proto__属性的浏览器下，我们可以通过下面的代码理解new的运算过程：
              <pre>{{ jsoopundestandnew }}</pre>
              (额外的解释部分图片资源破坏，就不多阅读)
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>
      <h2>4.this,call和apply</h2>
      <div></div>

      <div>
        <div>
          <h3>4.1 this</h3>
          <div>
            <stQuote class="mg-b10" :ctx="jsoopthis" />
            <p>
              (1) this的指向 <br>
              * 作为对象的方法调用，当函数作为对象的方法调用时，this指向该对象<br>
              <pre>{{ jsoopthisf1 }}</pre>
              * 作为普通函数调用，当函数不作为对象的属性被调用，也就是常说的普通函数方式，
              此时this总指向全局对象，在浏览器js里，这个全局对象时window <br>
              * 构造器调用，js里没有类，但是可以从构造器中创建对象（构造函数），同时也提供new操作符，
              使得构造器看起来像一个类。构造器里的this指向的时构造函数的实例 <br>
              * Function.prototype.call或Function.prototype.apply调用，call或apply可以动态改变传入函数的this
            </p>
            
          </div>
        </div>

      </div>
    </div>
  </div>
</template>

<style lang="less" scoped>
.jsoopbox {
  width: 100%;
}
</style>
