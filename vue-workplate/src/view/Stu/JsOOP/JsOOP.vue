<script setup>
import stQuote from "@/components/Card/st-quote.vue";
import { jsoopinfo, jsoopcodeinfo ,jsoopcodeinfopol,jsoopcodeinfoP,jsoopcodeinfoNoP} from "../data/designmodule";
</script>

<template>
  <div class="jsoopbox">
    <h2>1.面向对象的JavaScript</h2>
    <p>前言：</p>
    <stQuote class="mg-b10" :ctx="jsoopinfo" />

    <div>
      <h3>1.1 动态类型语言和鸭子类型</h3>
      <p>
        编程语言按数据类型大体可以分为2类，一类是静态语言类型，一类是动态语言类型。<br />
        静态类型语言在编译时已经确定变量的类型，而动态类型语言的变量类型需要程序运行时，待到变量被赋予某个值之后，才会被确定时某某类型。<br />
        所以对于js来说，他是一门典型的动态语言类型。
      </p>
      <p>
        动态语言类型对变量类型的宽容度给实际编码带来了很大的灵活性（同时也减弱了他的可维护性），
        由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。
      </p>
      <p>
        这一切都建立在<span style="color: blueviolet;"
          >鸭子类型(duck typing)</span
        >
        的概念上，鸭子类型的通俗说法是：若它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。
        <br />
        我们可以通过一个小故事来更深刻地了解鸭子类型. 从前在 JavaScript 王国里,
        有一个国王, 他觉得世界上最美妙的声音就是鸭子的叫声, 于是国王召集大臣,
        要组建一个 1000 只鸭子组成的合唱团. 大臣们找遍了全国, 终于找到 999 只鸭子,
        但是始终还差一只, 最后大臣发现有一只非常特别的鸡, 它的叫声跟鸭子一模一样,
        于是这只鸡就成为了合唱团的最后一员. <br>
      </p>
      <p>
        让我们用代码模拟一下这个场景：
        <pre>
          {{ jsoopcodeinfo }}
        </pre>

        从代码能看出，我们无需检测其类型，只需要保证它拥有duskSinging方法就行。
      </p>
      <p>
        在动态类型语言的面向对象设计中, 鸭子类型的概念至关重要. 利用鸭子类型的思想, 我们不必借助超类型的帮助, 就能轻松地在动态类型语言中实现一个原则: 
        <span style="color: red;">"面向接口编程, 而不是面向实现编程。"</span> 
      </p>
      <p>
        比如，一个对象又push和pop方法，并且这些方法提供了正确的实现，那它就可以被当作栈来使用。
        一个对象若有length属性，也可以依照下标来存取属性（最好还拥有slice和splice等方法），这个对象就能被当作数组来使用。
      </p>
      <p>
        在静态类型语言中，要实现面向接口编程并不是一件容易的事情，
        <span style="color: rgb(224, 125, 208);">往往要通过抽象类或者接口等将对象进行向上转型. 当对象的真正类型被隐藏在它的超类型身后, 这些对象才能在类型检查系统的 "监视" 之下互相被替换使用. 只有当对象能够被互相替换使用, 才能体现出对象多态性的价值.</span>
      </p>
      <p>
        <span style="color: red;">面向接口编程</span>是设计模式中最重要的思想。<br>
        但在js里，面向接口编程的过程和主流的静态类型语言不一样，所以在js中实现设计模式的过程与在一些我们熟悉的语言中实现大相径庭。
      </p>
    </div>
    
    <div>
      <h3>1.2 多态</h3>
      <p>
        "多态"一词源于希腊文 polymorphism, 拆开来看是 poly（复数） + morph（形态）+ ism, 从字面上我们可以理解为复数形态。<br>
        多态的实际含义是: 同一操作作用于不同的对象上面, 可以产生不同的解释和不同的执行结果。<br>
        换句话说，就是给不同对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同反馈。
      </p>
      <p>
        举个例子：<br>
        主人家里养了两只动物, 分别是一只鸭和一只鸡, 当主人向它们发出"叫"的命令时, 鸭会"嘎嘎嘎"地叫, 而鸡会"咯咯咯"地叫. 这两只动物都会以自己的方式来发出叫声. 它们同样"都是动物, 并且可以发出叫声", 但根据主人的指令, 它们会各自发出不同的叫声.
      </p>
      <p>
        让我们用代码模拟一下这个场景：
        <pre>
          {{ jsoopcodeinfopol }}
        </pre>
      </p>
      <p>
        多态背后的事项是将“做什么”和“谁去做以及怎样去做”分离开来，也就是“将不变的事物”和“可能改变的事物”分离。<br>
        在这个例子里，不变的是-动物都会叫，但不同类型的动物具体是怎么叫的是可变的。把不变的分离，可变的进行封装。这将给予程序可以生长的能力，符合开发-封闭原则。<br>
        相对于修改代码来说，仅仅增加代码就能完成同样的功能，这样显然优雅许多（这就是屎山的原因？）。
      </p>
      <p>
        现在用多态的思想改写一下鸭子类型的代码：
        <pre>
          {{ jsoopcodeinfoP }}
        </pre>
        把不变的隔离出来，那就是所有动物都会发出叫声；现在我们对鸡鸭都进行发出叫声的请求，他们对请求做出不同的翻译。<br>
        后续我们有加了一只狗，我们想让狗也叫一叫，那么直接追加就行，不需要改原代码。<br>
        反例：
        <pre>
          {{ jsoopcodeinfoNoP }}
        </pre>
      </p>
    </div>

    
  </div>
</template>

<style lang="less" scoped>
.jsoopbox {
  width: 80%;
}
</style>
