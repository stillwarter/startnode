<script setup>
import stQuote from "@/components/Card/st-quote.vue";
import {
  jsoopinfo,
  jsoopcodeinfo,
  jsoopcodeinfopol,
  jsoopcodeinfoP,
  jsoopundestand,
  jsoopcodeinfoNoP,
  jsooptype,
  jsoopextend,
  jsoopwork,jsooppackage
} from "../data/designmodule";
</script>

<template>
  <div class="jsoopbox">
    <div>
      <h2>1.面向对象的JavaScript</h2>
      <p>前言：</p>
      <stQuote class="mg-b10" :ctx="jsoopinfo" />

      <div>
        <h3>1.1 动态类型语言和鸭子类型</h3>
        <p>
          编程语言按数据类型大体可以分为2类，一类是静态语言类型，一类是动态语言类型。<br />
          静态类型语言在编译时已经确定变量的类型，而动态类型语言的变量类型需要程序运行时，待到变量被赋予某个值之后，才会被确定时某某类型。<br />
          所以对于js来说，他是一门典型的动态语言类型。
        </p>
        <p>
          动态语言类型对变量类型的宽容度给实际编码带来了很大的灵活性（同时也减弱了他的可维护性），
          由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。
        </p>
        <p>
          这一切都建立在<span style="color: blueviolet"
            >鸭子类型(duck typing)</span
          >
          的概念上，鸭子类型的通俗说法是：若它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。
          <br />
          我们可以通过一个小故事来更深刻地了解鸭子类型. 从前在 JavaScript
          王国里, 有一个国王, 他觉得世界上最美妙的声音就是鸭子的叫声,
          于是国王召集大臣, 要组建一个 1000 只鸭子组成的合唱团.
          大臣们找遍了全国, 终于找到 999 只鸭子, 但是始终还差一只,
          最后大臣发现有一只非常特别的鸡, 它的叫声跟鸭子一模一样,
          于是这只鸡就成为了合唱团的最后一员. <br />
        </p>
        <div>
          让我们用代码模拟一下这个场景：
          <pre>
          {{ jsoopcodeinfo }}
        </pre
          >

          从代码能看出，我们无需检测其类型，只需要保证它拥有duskSinging方法就行。
        </div>
        <p>
          在动态类型语言的面向对象设计中, 鸭子类型的概念至关重要.
          利用鸭子类型的思想, 我们不必借助超类型的帮助,
          就能轻松地在动态类型语言中实现一个原则:
          <span style="color: red">"面向接口编程, 而不是面向实现编程。"</span>
        </p>
        <p>
          比如，一个对象又push和pop方法，并且这些方法提供了正确的实现，那它就可以被当作栈来使用。
          一个对象若有length属性，也可以依照下标来存取属性（最好还拥有slice和splice等方法），这个对象就能被当作数组来使用。
        </p>
        <p>
          在静态类型语言中，要实现面向接口编程并不是一件容易的事情，
          <span style="color: rgb(224, 125, 208)"
            >往往要通过抽象类或者接口等将对象进行向上转型.
            当对象的真正类型被隐藏在它的超类型身后, 这些对象才能在类型检查系统的
            "监视" 之下互相被替换使用. 只有当对象能够被互相替换使用,
            才能体现出对象多态性的价值.</span
          >
        </p>
        <p>
          <span style="color: red">面向接口编程</span
          >是设计模式中最重要的思想。<br />
          但在js里，面向接口编程的过程和主流的静态类型语言不一样，所以在js中实现设计模式的过程与在一些我们熟悉的语言中实现大相径庭。
        </p>

        <div>
          <div>
            <h3>1.2 多态</h3>
            <p>
              "多态"一词源于希腊文 polymorphism, 拆开来看是 poly（复数） +
              morph（形态）+ ism, 从字面上我们可以理解为复数形态。<br />
              多态的实际含义是: 同一操作作用于不同的对象上面,
              可以产生不同的解释和不同的执行结果。<br />
              换句话说，就是给不同对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同反馈。
            </p>
            <p>
              举个例子：<br />
              主人家里养了两只动物, 分别是一只鸭和一只鸡,
              当主人向它们发出"叫"的命令时, 鸭会"嘎嘎嘎"地叫,
              而鸡会"咯咯咯"地叫. 这两只动物都会以自己的方式来发出叫声.
              它们同样"都是动物, 并且可以发出叫声", 但根据主人的指令,
              它们会各自发出不同的叫声.
            </p>
            <div>
              让我们用代码模拟一下这个场景：
              <pre>
              {{ jsoopcodeinfopol }}
            </pre
              >
            </div>
            <p>
              多态背后的事项是将“做什么”和“谁去做以及怎样去做”分离开来，也就是“将不变的事物”和“可能改变的事物”分离。<br />
              在这个例子里，不变的是-动物都会叫，但不同类型的动物具体是怎么叫的是可变的。把不变的分离，可变的进行封装。这将给予程序可以生长的能力，符合开发-封闭原则。<br />
              相对于修改代码来说，仅仅增加代码就能完成同样的功能，这样显然优雅许多（这就是屎山的原因？）。
            </p>
            <div>
              现在用多态的思想改写一下鸭子类型的代码：
              <pre>
              {{ jsoopcodeinfoP }}
            </pre
              >
              把不变的隔离出来，那就是所有动物都会发出叫声；现在我们对鸡鸭都进行发出叫声的请求，他们对请求做出不同的翻译。<br />
              后续我们有加了一只狗，我们想让狗也叫一叫，那么直接追加就行，不需要改原代码。<br />
              反例：
              <pre>
              {{ jsoopcodeinfoNoP }}
            </pre
              >
            </div>

            <stQuote class="mg-b10" :ctx="jsoopundestand" />
          </div>
          <div>
            <h3>1.3 类型检查和多态</h3>
            <div>
              类型检查是在表现出对象多态性之前的一个绕不开的话题, 但 JavaScript
              是一门不必进行类型检查的动态类型语言, 为了真正了解多态的目的,
              我们需要转一个弯, 从一门静态类型语言说起。<br />
              之前提到，静态类型语音会在编译德时候进行类型匹配检查。以java为例
              由于代码编译的时候要进行严格的类型检测，所以不能给变量赋予不同类型的值，
              这种类型检查会让代码显得僵硬：
              <pre>
              {{ jsooptype }}
            </pre
              >
              这里已经顺利的让鸭子发出叫声，但若你想让鸡也叫起来，这是不可能的。
              因为行1处animalsound类的makesound方法，被规定只能接受Duck类型参数
            </div>
            <p>
              某些时候，在享受静态语言类型检查带来的安全性的同时，我们亦会感受到被束缚了手脚。
              为解决这一问题，静态类型的面向对象语言通常被设计为可以“向上转型”
              <span style="color: red"
                >当给一个变量赋值时，这个变量的类型既可以使用这个类本身，也可以使用这个类的超类（父类）。</span
              >
              <br />
              这就是我们在描述一只麻雀在飞的时候，也可以说是一只鸟在飞。<br />
              同理，当duck对象和chicken对象的类型都被隐藏在超类型animal身后，duck对象和chicken对象就能被交换使用。
              这就是让对象体现出多态性的必进之路，而多态的表现正是实现众多设计模式的目标。
            </p>
          </div>
          <div>
            <h3>1.4 使用继承达到多态效果</h3>
            <div>
              <span style="color: red"
                >使用继承来得到多态效果，是让对象表现出多态性的最常用手段。</span
              >
              继承通常包括“实现继承”和“接口继承” 直接上代码：
              <pre>
              {{ jsoopextend }}
            </pre
              >
            </div>
            <div>
              以上是java的写法，之前的内容其实是让你理解多态的思想--就是把“做什么”和“谁去做”分离开来，
              实现这一点归根结底需要消除类型之间的耦合关系，就是我们需要将makesound方法中指定的对象升级为父类。
              <br />
              而js的变量类型在运行期间是可变的，这意味着<span style="color: red"
                >js对象的多态性是与生俱来的</span
              >。
              <br />
              这并不难理解，js既没有检查创建的对象类型，也没有检查传递的参数类型，所以不会有“类型耦合”。
            </div>
          </div>

          <div>
            <h3>1.5 多态在面向对象程序设计中的作用</h3>
            <div>
              有人认为多态是oop最重要的部分，但目前还是很难体会到，毕竟大部分人不关心鸡鸣狗叫的，让鸡呀鸭呀的发出叫声，这和程序有什么关系呢。
              <br />
              <stQuote class="mg-b10" :ctx="jsoopwork" />
              换言之，多态最根本作用就是通过将‘过程化的条件分支语句’（很多if判断）转化为‘对象的多态性’（不同对象的表现？），
              从而消除这些分支语句。
            </div>
          </div>
        </div>
      </div>
    </div>
    <div>
      <h2>2.封装</h2>
      <p>前言：</p>
      <stQuote class="mg-b10" :ctx="jsooppackage" />
      <div>
        <div>
          <h3>2.1 封装数据</h3>
        </div>
      </div>
    </div>
  </div>
</template>

<style lang="less" scoped>
.jsoopbox {
  width: 100%;
}
</style>
